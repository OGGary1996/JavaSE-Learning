package training.tutorialAdvanced.a_oop.f_interface;

// 存在意义：
    // 1.在之前的Person -> Student中，我们使用了抽象类类强制子类实现父类的方法
    //   但是如果有一部分的子类不需要实现这个父类的方法，那么就会导致我们无法使用抽象方法并强制所有子类都区实现它，最终还是只能在不同子类中各自定义这个方法
    //   所以这个时候我们可以单独定义一个接口，这个接口定义了一个方法，如果有部分的子类需要实现这个方法，那么就可以实现这个接口，而不影响其他子类
    // 2.接口不同于继承的概念，接口不强调继承，接口强调的时候某一些类可能有一些共同的行为（虽然实现的方式不同），而接口来提供这个行为的规范
    //   也就意味着，如果有一个方法需要传递的参数是一个共同的父类，那么这个情况下可能有些子类有这个接口的实现，而有些子类没有这个接口的实现
    //   这个时候我们就可以定义一个接口，接口中定义了这个方法的规范，然后用这个接口实现的类作为参数传递，从而实现了更加精细的控制和设计。

// 解释：
    // 1.接口与继承没有关系，同一个接口可以存在于多个继承体系中，可以同时存在继承和接口实现。
    // 2.接口的实现是多重的，一个类可以实现多个接口
    // 3.接口和接口之间，是可以有继承关系的，但是在实现某个接口的时候，必须实现所有的它的父接口中的方法

// 接口中成员的特点：
    // 1.接口中的成员变量默认是public static final的，因为接口中只定义规则，而不去定义有属性的变量
    // 2.接口没有构造方法
    // 3.接口中的成员方法默认是public abstract的，接口中定义的方法是没有方法体的
        // 2.1 接口中也可以定义方法体，但是这个方法体是默认实现的，接口中的方法体是default修饰的
        //     这个做法是为了接口的升级，如果后续接口中有更新，只需要加上默认的方法体，而无需区修改所有实现了这个接口的类。
        //     如果后续需要重写这个默认的方法体，那么就可以在实现这个接口的类中重写这个方法，需要去掉default修饰。
        // 2.2 接口中也可以定义静态方法，静态方法是可以直接通过接口名调用的

public class a_interface {
    // 使用接口作为参数传递，可以将所有实现了这个接口的类都传递进来；也叫做接口的多态
    public static void printAbility(Swimming swimming){
        swimming.swim();
    }

    public static void main(String[] args) {
        // 1.接口的实现是多重的，一个类可以实现多个接口
        Dog dog = new Dog("dog", 2);
        dog.eat();
        dog.swim();

        Frog frog = new Frog("frog", 3);
        frog.eat();
        frog.swim();

        Rabbit rabbit = new Rabbit("rabbit", 4);
        rabbit.eat();

        printAbility(dog);

    }
}
