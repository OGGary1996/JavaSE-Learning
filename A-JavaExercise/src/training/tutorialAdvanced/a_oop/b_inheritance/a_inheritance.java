package training.tutorialAdvanced.a_oop.b_inheritance;

// 子类可以继承哪些：
    // 1.子类无论如何都无法继承父类的构造方法，不管是private还是public,只能通过手动创建构造器之后在内部通过super调用父类的构造器
        // 1.1 如果子类没有构造器，则默认会调用父类的无参构造器
        // 1.2 如果子类有构造器，也会默认调用父类的无参构造器，也可以手动调用父类的有参构造器
        // 1.3 如果父类没有无参构造器，则必须手动调用父类的有参构造器
    // 2.子类可以继承父类的成员变量，即使成员变量是private，只是子类无法直接访问，需要通过父类的public set get方法访问
        // 2.1 如果子类变量名与父类变量名相同，则在堆空间中会创建两个变量，分别是子类的成员变量和父类的成员变量
    // 3.子类可以继承父类的public方法和protected方法，但是不能继承私有方法

// 内存分析
    // 1. 当类被初始化时，在方法区会同时创建它的父类和Object类的结构信息
    // 2. 当类被创建时，在子类的堆区，除了它本身的成员信息以外，还会创建继承自父类的成员信息。
        // 2.1 如果父类的成员变量是private，则不会加载到子类的堆区
        // 2.2 当给子类的成员对象赋值时，如果找不到子类的对应变量，则可以在堆区找到对应 继承自父类 的成员对象

// 继承中成员变量的访问特点：静态绑定
    // 1. 访问成员变量遵循就近原则，先查找子类的成员变量，如果找不到，则查找父类的成员变量
    // 2. 如果子类的成员变量和父类的成员变量同名，则可以使用this,super来区分

// 继承中成员方法的访问特点：动态绑定
    // 1. 访问成员方法遵循就近原则，先查找子类的方法，如果找不到，则查找父类的方法
    // 2. 如果子类的方法和父类的方法同名，则可以使用this,super来区分
    // 3. 方法的代码虽然来自父类，但是在运行时会根据对象的实际类型来决定调用哪个方法
        // 3.1 如果子类重写了父类的方法，则调用的是子类的方法
        // 3.2 如果子类没有重写父类的方法，则调用的是父类的方法，只是这个方法的this指向的是实际上的子类对象，所以还是在操作子类对象
        // 3.3 如果父类的方法是private，则无法被子类重写，只能被子类继承

// 继承中构造器的访问特点：
    // 1. 子类的无参构造器必须会隐式调用父类的无餐构造器，super().因为必须要初始化父类的成员变量
    // 2. 如果子类的构造器没有显示调用父类的构造器，则默认调用父类的无参构造器
    // 3. 如果父类没有无参构造器，则必须显示调用父类的有参构造器

// this,和super的区别
    // 1. this可以理解为一个变量，是当前方法调用者的地址，super是指向父类对象的引用
    // 2. this可以访问当前类的成员变量和方法，super可以访问父类的成员变量和方法
    // 3. this可以调用当前类的构造器；
        // 3.1 this()调用当前类的构造器，this(参数)调用当前类的有参构造器
    // 4. super可以调用父类的构造器

    /*
    * super关键字是子类与父类互动的桥梁，它让子类能够明确地访问父类的构造方法、成员变量和方法。
    * 正确使用super可以帮助你有效地利用继承机制，在扩展父类功能的同时重用父类代码。
    */


public class a_inheritance {
    public static void main(String[] args) {
        // 1. 创建一个Manager对象
        Manager manager = new Manager("001", "张三", 10000, 2000);
        // 2. 调用父类的方法
        manager.work();
        manager.eat();
        // 3. 调用子类的方法
        System.out.println("Bonus: " + manager.getBonus());

    }
}
